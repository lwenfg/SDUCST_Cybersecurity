# 第一章 计算机网络基础

## 1.1网络空间

**网络空间（Cyberspace）：**是哲学和计算机领域中的一个抽象概念，指在人运用信息通讯系统进行交互的虚拟空间。

**网络空间是一个虚拟的空间**，虚拟空间包含三个基本要素：

- 第一个是载体，通讯系统；
- 第二个是主体，网络用户；
- 第三个是虚拟的交互空间

## 1.2地址

**IP地址（Internet Protocol Address）**是**分配**给网络设备的唯一标识符，用于在互联网上或局域网中标识设备和实现它们之间的通信

**MAC地址（Media Access Control address）**是用于**标识**网络设备的唯一标识符，是一个由6组十六进制数字（0-9，A-F）组成的48位地址。

## 1.3子网

- 什么是子网：计算机网络中，将一个大型网络划分为若干个较小的独立网络。这些较小的网络称为子网
- 定义子网的方法-子网掩码：是一个与IP地址长度相同的二进制数，通过它可以将一个IP地址划分为**网络部分**和主机部分。
- 无类别域间路由（CIDR）：
- “IP地址/前缀长度”的格式来表示网络

## 1.4 以太网交换机

以太网交换机是连接互联网中多个网络设备并使其能够互相通信的网络设备

以太网交换机工作原理：载波侦听多路访问/冲突检测（CSMA/CD），根据数据帧的目标MAC地址，查找MAC地址和端口映射表，转发数据帧。

## 1.5路由器

路由器是一种工作在网络层的专用网络连接设备，它的功能主要是路由转发，即根据数据包的目的IP地址和本地的路由表信息把数据包转发到相应的接口上。

路由器的转发原理：根据目的IP地址、查找路由器内部的路由表，把数据包转发到路由器相应的输出端口。

## 1.6常用工具介绍（待补充）

### Scapy

用 Python 语言编写的功能强大的交互式数据包构造、解析程序和库，支持多种协议。

# 第二章 网络基础漏洞

- 缺陷Bug：**软件程序**中的错误或弱点，导致程序运行异常、崩溃或者产生不正确的结果。
- 漏洞Vulunerabilities：是**系统**需求、设计、实现或运行中的**缺陷或弱点**，这些缺陷或弱点可能被意外触发或故意利用。
- 利用exploit：是一段软件、一组数据或一系列命令，利用漏洞或缺陷引发非预期行为。

## 2.1 内存相关漏洞

内存缓冲区溢出：输入数据超出分配的缓冲区大小

数据扩展漏洞：解压缩后的数据长度超过了缓冲区的大小

缺省/硬编码漏洞：是用于调试目的、有意制造的后门。

CPU耗尽攻击：如在冒泡排序中指定大量反向排序的值。

## 2.2 网络相关漏洞

### 2.2.1 面向报文头

- 源地址和目的地址操控
- 在报文头中设置不应设置的比特
- 在报文头中设置超出或低于标准规定范围的值

### 2.2.2 面向协议

- 发送数据包通知设备停止通信
- 对于无连接协议，您可以充当服务器并告诉客户端服务器已关闭

例子：SYN洪范攻击、广播洪范攻击

### 2.2.3 面向认证

在网络中，通常使用地址来认证数据包：在网络中，通常使用地址来认证数据包。

### 2.2.4 面向网络流



# 第三章：局域网安全

## 3.1 局域网协议概述

IEEE 802协议簇涵盖了各种局域网和城域网的网络技术标准，旨在规范计算机网络设备之间的通信和互操作性。**其中802.3是有线以太网协议，802.11是无线以太网协议**。

**以太网协议**

以太网络协议(802.3协议）规范了以太网络的物理层和数据链路层，协议包含7个通用的字段，包括前导码、起始帧定界符、目的MAC地址、源MAC地址、长度/类型、可变长度的数据和帧校验序列等字段。

- 前导码和起始帧定界符：帮助接收方识别帧开始的位置
- 目的/源 MAC地址：指明了目标/发送设备的MAC地址
- 长度/类型：用于指示帧的有效长度和协议类型
- 数据：网络层传递给数据链路层的报文
- 帧校验序列：用于检验帧在传输过程中是否发生了数据损坏

### 3.1.1 CSMA/CD协议

载波侦听多路访问/冲突检测用于协调多个设备在同一共享通信介质上进行数据传输，以防止冲突。

### 3.1.2 ARP协议

主要功能是将网络层的IP地址解析为数据链路层的物理地址（通常是MAC地址）。

ARP协议的主要工作流程分为以下四步：

1. 发起请求ARP Request：当局域网中主机A主机B通信时，A会检查自己的ARP缓存表，查看是否已经有B的IP地址对应的MAC地址。如果没有，A将广播一个ARP请求包到局域网中，询问B的IP地址对应的MAC地址。
2. 广播信息：由于ARP请求是以广播形式发送的，局域网中所有设备都会接收到A的请求。请求包含A的IP和MAC地址，以及目标B的IP地址。
3. 发送响应ARP Reply：当主机B识别到ARP请求中的IP地址与自己的IP地址相匹配时，它会向发起ARP请求的设备发送一个ARP响应。这个响应包含B（即响应设备）的IP和MAC地址。
4. 添加缓存：当A收到B的ARP响应后，会将B的IP地址和MAC地址的映射写入A的ARP缓存表中，之后它就可以开始使用这个MAC物理地址来发送数据帧到局域网中的A。

### 3.1.3 DHCP 协议

DHCP(Dynamic Host Configuration Protocol)协议又称动态主机配置协议，是一种常见的网络管理协议，主要为客户端提供：

- IP地址
- 子网掩码
- 路由器的IP
- 地址域名
- 服务器的IP地址

DHCP服务器有两个数据库：静态IP池和动态池。服务器在动态池之前检查静态池的匹配项，动态池中的地址是临时的。DHCP协议交互过程如下：

1. **发现阶段**：客户端以广播的方式发送DHCP Discover报文，用于求IP地址分配。
2. **提供阶段**：DHCP服务器接收到广播报文后，向客户端发送DHCP Offer响应报文，报文包含服务器本身的IP、分配给客户端的IP、子网掩码和网关信息等。
3. **请求阶段**：客户端选择**第一个**收到的DHCP Offer响应报文（可能有多个服务器发送了提供报文），并再次**以广播**的形式发送条DHCP Request报文，通知服务器此时客户端选择的配置。
4. **确认阶段**：服务器收到DHCP Request请求报文后，再向客户端发送DHCP ACK确认报文，确认分配的IP和所分配的时长，从这个时候起客户端才能使用该IP地址，这个状态称为绑定状态。
5. **更新阶段**：当客户端租用期过了一半时，向服务器发送DHCP Request报文请求更新租用时长。若服务器同意，则发送DHCP ACK确认报文；若不同意则发送DHCP NACK，此时会停止使用原来的IP。
6. **释放阶段**：DHCP客户端可以通过向DHCP服务器发送DHCP Release释放报文来释放IP。

## 3.2 局域网相关攻击

### 3.2.1 MAC地址洪范攻击

攻击原理：**以太网交换机**中维护着一个MAC地址表，记录了每个MAC地址对应连接到交换机的哪个端口。交换机收到一个未知源MAC地址时，会更新其MAC地址表：将每一个伪造的“源MAC地址”和攻击者所连接的端口号记录到自己的MAC地址表中。而交换机的MAC地址表大小是固定的，只能存储有限数量的MAC地址与端口映射。

攻击步骤如下：

- 攻击者发送大量伪造的数据帧，这些数据帧的源MAC地址是随机伪造的、目的MAC地址是随机地址或广播地址。攻击者通过向网络中注入大量伪造的数据帧，以填满交换机的MAC地址表；
- 交换机无法正常处理新到达的数据帧。当交换机的MAC地址表填满后，交换机无法再将新的MAC地址和端口对应起来；
- 交换机广播收到的数据帧。在无法正确转发数据帧时，交换机只能将数据帧广播到所有连接的端口上。此时攻击者可接收到受害者的数据帧，然后可借助如Wireshark等工具获取数据信息。

### 3.2.2 ARP 攻击

ARP缓存投毒攻击利用了**ARP协议缺乏有效的验证机制**，无法确保ARP响应的真实性的缺陷，该攻击使得攻击者能够通过破坏网络的MAC地址表（MAC地址到IP地址的映射）来截获、篡改或中断网络设备之间的通信。

#### ARP Reply攻击

在ARP Reply方式中，攻击者向受害者发送伪装的ARP Reply响应，欺骗受害者将攻击者的MAC地址与服务器端的IP地址关联。

- 受害者想知道服务器的IP地址，于是发送广播请求ARP Request。此时同一个局域网的攻击者也可收到这个广播消息
- 攻击者比服务器更快地回应伪造的ARP Reply响应。该响应告诉受害者：IP地址为服务器的，其MAC地址为攻击者的MAC地址。这导致受害者ARP缓存表中记录了错误的映射
- 受害者发送给服务器的流量会发送给攻击者。

#### ARP Request攻击

攻击者向服务器发送虚假的请求ARP Request，欺骗服务器端将受害者的IP地址与攻击者的MAC地址相映射，使得服务器端的ARP缓存表中出现错误的映射。

#### 终端主机欺骗攻击

利用ARP缓存投毒攻击可以实现**终端主机**欺骗（End Host Spoofing），假设主机A和攻击者都连接到同一网关上，然后通过路由连入互联网，攻击步骤如下：

- 攻击者发送伪造数据包，将**网关的MAC地址表**中与主机A的IP地址所对应物理MAC地址污染成为攻击者的物理地址（MAC地址）
- 服务器与攻击者通信，网关由于受其地址表被污染的影响，会将来自互联网中需要传递给主机A的数据包首先发送给了攻击者，然后攻击者再转发给主机A

#### 网关欺骗攻击

假设**服务器**和攻击者都连接到同一网关上，然后通过路由设备连入互联网。

- 攻击者发送伪造的数据包，将服务器的ARP缓存中将网关IP地址对应的MAC地址污染为攻击者的MAC地址
- 服务器与攻击者通信，后续步骤同终端主机欺骗。

#### 中间人Telnet攻击

中间人攻击是在ARP缓存投毒攻击的基础上，劫持受害者主机与网络服务器之间的数据流量。在劫持攻击发生前，攻击者主机定期向局域网广播伪造的ARP应答报文。在ARP应答报文中，攻击者主机将**网络服务器IP地址**与**自身MAC地址**进行绑定。一旦受害者主机接收到该ARP应答报文，其MAC地址表会创建一条将服务器的IP地址与攻击者主机MAC地址绑定在一起的ARP表项。

### 3.2.3 DHCP攻击

DHCP劫持攻击是一种涉及**中间人**的攻击方式。攻击者通过干扰DHCP通信，利用受控的恶意DHCP服务器，试图引导网络设备接受伪造的网络配置，从而实施潜在的攻击行为。

#### DHCP 劫持攻击

假设在一个局域网中有客户端、服务器和攻击者，攻击步骤如下：

- 设置伪造的DHCP服务器，会在客户端发送DHCP Discover包时，伪造服务器响应DHCP Offer包，提供错误的网络配置信息。
- 响应请求DHCP Request，当客户端发送DHCP Request后，恶意服务器发送 DHCP ACK确认，其尝试比合法DHCP服务器更快响应请求，以确保客户端接受其配置
- 劫持网络流量，一旦客户端使用了伪造的服务器提供的配置信息时，其对外请求的流量都可能使用攻击者指定的网关和DNS服务器，使得攻击者能够监视、拦截或篡改网络流量。

#### DHCP 拒绝服务攻击

DHCP拒绝服务攻击通过使DHCP服务器无法正常工作，导致网络中的设备无法获取有效的IP地址配置。

攻击者通过不断发送DHCP Discover，在收到服务器发送的 DHCP Offer 数据包并提取相关信息，构建大量的DHCP Request 数据包，这些数据包使用不同的、多为伪造的MAC地址，致使DHCP服务器尝试为每个请求分配IP地址，以大量占用DHCP服务器的资源和带宽，导致DHCP服务器上可用于分配的地址资源耗尽，从而使得正常的DHCP服务受到影响。

### 3.2.4 防御手段

预防ARP攻击的方法：

- 动态ARP检测：**交换机**对经过其所有的**ARP请求和响应**包进行拦截和验证。使用**DHCP监听绑定表**，当网络中使用DHCP服务器动态分配IP时，交换机会监听并记录下合法的“IP地址 - MAC地址 - 接入端口”的绑定关系。
- 使用静态ARP表
- 使用VLAN将网络分隔，**限制ARP攻击范围**：ARP广播包默认只在同一个**广播域**内传播。VLAN（虚拟局域网）技术将一个大的物理网络在二层逻辑上划分成多个小的广播域。ARP请求/响应无法跨越不同的**VLAN**
- 防火墙：防火墙会学习并维护一个合法的IP-MAC地址绑定表。当检测到内网发出的ARP包中的映射关系与绑定表不符时，会将其视为攻击包并丢弃。

预防DHCP攻击的方法：

- VLAN隔离：在不同的广播域中，广播报文无法跨越VLAN（抵御DHCP洪范攻击）
- 为关键设备静态分配IP
- **启用DHCP snooping**：**交换机**建立一张**动态的DHCP绑定表**，并基于此表对DHCP报文进行过滤。分为信任端口和不信任端口，交换机只允许从“信任端口”收到的DHCP服务器响应包通过，也可以检查DHCP请求报文的源MAC地址等字段。

# 第四章 传输层安全

## 4.1 传输层协议概述

### 4.1.1 TCP协议

#### TCP 报文格式

- 源端口/目的端口：发送方和接收方端口号
- 序列号（32位）：用于确保数据传输的顺序性与可靠性
- 确认序列号（32位）：接收方用来告诉发送方其所期望的下一个序列号
- 数据偏移（4位）：指示数据开始的位置相对于TCP段开始的偏移量
- 控制位和标志位：其中CWR/ECE用于显示拥塞通知；URG是紧急指针标志；ACK是确认号标志；PSH是接收方应尽快将该报文提交到应用层；RST是重置连接标志；SYN是初始连接标志；FIN是任务完成标志
- 窗口大小
- 校验和
- 紧急指针
- 填充

#### TCP 三次握手

1. 第一次握手：客户端发送SYN报文。客户端向接收方发起TCP报文，报文中SYN位设置为1，表示这是连接请求，序列号设置为X作为本次数据传输的起始序列号。
2. 第二次握手：服务器回应SYN-ACK报文。服务器收到请求后，发送SYN-ACK报文，报文中SYN和ACK均设置为1，序列号为Y，确认序列号为X+1，表示服务器已经收到请求且准备好连接。
3. 第三次握手：客户端发送ACK报文。客户端收到SYN-ACK后，回复一个ACK报文，其序列号为X+1，确认序列号为Y+1，表示客户端同意并确认连接。

#### TCP 传输窗口

在TCP分组发送过程中， 上一个分组发送成功并得到确认后， 下一个分组才能发送，这会导致传输效率低下。传输窗口通过允许发送方在收到确认之前发送多个数据报文，显著提高了传输效率。

发送窗口：由接收方通告的传输窗口大小决定，表示发送方在等待确认之前可以发送的最大数据量。接收窗口：接收方根据自己的缓冲区大小，通告能够接收的数据量。这种方式提高了TCP协议的传输效率。

#### TCP状态自动机

### 4.1.2 UDP协议

**用户数据报协议（User Datagram Protocol，UDP）**是一种面向无连接的传输层协议，旨在提供简单、低延迟的数据传输服务，常见的适用场景包括：实时音视频传输、广播和多播传输以及较为简单的查询协议。

UDP的报文**头部固定为8个字节**：

- 源端口
- 目的端口
- 长度：表示整个UDP报文的长度
- 校验和：用于检测报文在传输过程中是否损坏

## 4.2 传输层相关攻击

### 4.2.1 TCP端口扫描

TCP全连接扫描：完成完整三次握手，准确但易被日志记录。

TCP半连接扫描：攻击者在收到SYN-ACK后发送**RST报文**，扫描速度较快，具有一定的隐蔽性。

**更隐蔽的扫描：**

攻击原理：根据TCP协议的规定。如果端口是开放的，往往会忽略这类非法数据包；**如果端口是关闭的，则会响应RST报文**。因此，通过观察是否收到RST响应，可以推断出目标端口的开放状态。

- TCP Maimon扫描：向目标端口的TCP连接发送一个同时设置**FIN和ACK标志位**的数据包。
- TCP Null扫描：扫描者发送一个**不带任何TCP标志**的数据包（即所有的标志位都设为0）。
- TCP FIN扫描：扫描者发送一个只设置了**FIN标志位**的TCP数据包。
- TCP Xmas扫描：这种扫描方法得名于数据包中设置的多个标志位（**FIN, PSH, 和 URG**）。

### 4.2.2 UDP扫描

攻击原理：扫描者向目标端口发送一个空的UDP请求，如果收到了ICMP端口不可到达错误，则表示端口关闭；反之，没有响应则表明端口开放。

### 4.2.3 隐蔽扫描-idlescan空闲扫描（回头要重点复习）

攻击原理：**IPID**称为IP标识符，它是IP协议数据包头部的一个16位字段，核心作用是**标识同一个IP数据包的多个分片**。当一个数据包的大小超过网络链路的**最大传输单元（MTU）** 时，它会被分割成多个更小的“分片”进行传输。接收方在收到这些分片后，需要将它们重新组合成原始的数据包。IPID就是这个重组过程的“凭据”：具有相同IPID的分片被视为同一个原始数据包，接收方会将具有相同IPID的分片合并在一起。

许多操作系统为了实现简单，采用了一种**全局递增**的方式为每个发出的IP数据包分配IPID值。系统维护一个全局计数器，**每发送一个IP包（无论是何种协议，如TCP、UDP、ICMP），该计数器就加1**。因此，通过观察连续两个IP包的IPID值，就可以知道在这期间系统总共发送了多少个IP数据包。

**攻击步骤：**

1. 探测空闲主机的IPID值：扫描者A首先探测空闲主机C的IPID值，向空闲主机发送一个ICMP请求。空闲主机接收到请求后会回复一个ICMP响应，并且其IP层中的ID字段（IPID）会被记录下来。
2. 伪造IP地址发送SYN请求：扫描者A伪造主机C的IP地址，向目标主机B发送SYN请求。
3. 观察IPID值变化：如果目标端口开放，目标主机会向主机C回复SYN-ACK报文，导致主机C产生一个RST响应并增加其IPID值。如果目标端口未开放，主机C的IPID值不会变化。
4. 再次探测IPID值：扫描者A再次探测主机C的IPID值，比较前后的IPID值变化，以确定目标B的端口状态。如果IPID值增加2，则目标主机的目标端口开放；如果IPID值增加1，则目标主机的目标端口关闭。



### 4.2.4 资产探查

资产探查并非单一技术，而是一个多层次的过程，旨在回答关于目标网络的几个核心问题：

1. **有哪些主机是存活的？**
2. **这些主机上开放了哪些端口？**
3. **这些端口上运行着什么服务及版本？**
4. **主机的操作系统或设备类型是什么？**

在现实世界中，不同的网络设备、协议实现和软件应用在网络连接中可能会表现出极为细微的差异。这些在通信连接中表现出来的独特特性被称为设备、系统或软件的“**指纹（Fingerpint)**”。

在利用上述方法获得开放端口后，需要识别端口上运行的服务及其版本，甚至识别主机的操作系统。这被称为“**指纹识别**”。

- 被动指纹识别：不向目标发送任何包，仅**监听**目标正常通信时产生的流量，分析其TCP/IP协议栈的**细微特征**：观察目标发送的SYN/SYN-ACK/RST 等包中的 TTL、Window Size、IPID、TCP 选项顺序/存在性等，可以大致推断目标系统的类型（因不同操作系统这些值不尽相同）。或观察**被动应用层/浏览器指纹**：观察 HTTP headers、Cookie 特征、TLS 指纹、DNS 查询模式等组合来推断操作系统或应用
- 主动指纹识别：向目标发送一系列**特殊构造的探测包**，观察其响应包的差异，与指纹数据库进行匹配。

资产探查常用的工具有hping3和nmap。

### 4.2.5  TCP SYN flood攻击

**攻击原理**：攻击者向受害者主机发送大量TCP SYN请求；受害者回复SYN-ACK响应并维护**一个半连接状态**，等待客户端回复ACK数据包；最后，攻击者不断重复上述过程，发送大量恶意SYN请求，但不发送TCP三次握手的第三个包。使得受害者消耗大量资源来**维持这些半开放连接**，最终导致受害者的资源耗尽，无法为正常连接的请求提供服务。

防范TCP SYN flood攻击的方法有：**增加半打开队列长度、降低表项回收时间、SYN cookie**

有效防范 TCP SYN flood攻击的方法：**SYN Cookie**

1. 服务器接收SYN包
2. 服务器计算cookie值，根据SYN包的内容计算出一个cookie值
3. 发送SYN-ACK包：服务器将cookie值作为SYN-ACK的初始序列号发给客户端
4. 客户端发送ACK包后服务器进行验证：提取ACK包中的确认号是否为cookie+1.如果验证通过服务器才分配资源建立TCP连接。

SYN Cookie 机制取消了服务器段为了保存半打开状态所需要的存储资源，而是把状态保存在传输数据包的序列号或应答号（即 Cookie）中。由于SYN Cookie机制并没有改变TCP连接的过程，而仅仅是避免了大量的半开放式连接对于资源的消耗，因此可以在不修改TCP协议基础的情况下有效抵御泛洪攻击。

### 4.2.6  TCP 会话的劫持与重置攻击

#### TCP会话劫持

1981年RFC793发布后，大部分操作系统对于TCP初始序列号的实现采取了**全局线性增长**的方案，由一个全局的时钟发生器产生初始序列号。我们知道如果一旦TCP的序列号可以被攻击者预测或推测，那么攻击者就完全有可能向TCP连接中注入恶意的TCP报文，从而干扰或者劫持整个TCP会话。

由于是全局线性增长的，攻击者只需要先于受害者建立一个TCP连接，便可以获取全局计数器，进一步预测下一个序列号。攻击者一旦获得了 TCP 序列号，就可以通过伪造报文的方式发送恶意内容，从而接管整个连接，完成 TCP 劫持。

有效防御TCP会话劫持的方法就是**TCP序列号随机化**

#### TCP序列随机化（回头需要再理解）

为了改进TCP协议的安全性， 1996 年发布的 互联网技术标准RFC 1948中引入了初始序列号的随机化机制。但是TCP序列号预测的风险并没有被完全消除，2007年发现利用IPID侧信道仍然可以对TCP序列号进行预测。而TCP协议为攻击者提供了**验证其猜测是否正确的方法**。

原理：依据 RFC 标准当收到一个 TCP 报文但**序列号或确认号错误时**，会简单地回复一个**ACK 报文**来明确正确的序列号、确认号。

假设客户端A和B都与服务器S进行正常通信。攻击者的目标是推测出服务器S用于与A或B通信的当前序列号。攻击步骤如下：

- 攻击者首先向客户端A和B发送ICMP Echo请求等探测包，从回复中获取它们当前的IPID值，记为N_A和N_B。
- 攻击者伪造源IP地址为服务器S，向客户端A和B分别发送伪造的TCP数据包（例如，一个**SYN-ACK包**）。在这个包中，攻击者填入他**猜测的序列号**。
- 若序列号猜测错误：根据TCP协议，客户端会向服务器S回复一个ACK包，明确指出正确的序列号。**这个ACK包的发送，会导致客户端B的IPID值增加1。**
- 若序列号猜测正确：客户端会将其**丢弃**（因为客户端没有发起连接却收到了SYN-ACK），此时IPID值不变。
- 最后攻击者再次向客户端发送ICMP请求，通过响应中的 IPID 值的变化就可以得知之前的预测是否正确。增加1，则序列号预测正确；增加2，则不正确。

#### TCP重置攻击

当攻击者**掌握了TCP序列号后**，除了劫持会话，还可以选择更加简单直接的**状态干扰攻击**。攻击者可利用TCP协议自身的设计机制，通过干扰TCP连接状态以中断通信的攻击方式。攻击者通过伪造源IP地址，在正常通信流量中注入一个RST报文，强制断开连接。

### 4.2.7 反射放大攻击

攻击者只需要通过伪造**源IP地址**（受害者主机地址）的方式来向服务提供者**发送请求**，从而使得响应被回复给受害者，从而形成“反射”操作。

反射放大攻击的原理：反射放大攻击的攻击目标并不是提供服务的设备本身，而是利用它们作为工具来间接地实施攻击，即让服务提供设备称为“放大器”。反射放大攻击就像名字一样包含两部分：反射和放大。

攻击者伪造源地址发送请求，当放大器收到请求会向受害者回复一个响应，而这其中，**请求的报文大小要比响应小得多**。所以伪造源地址造成了反射行为，而请求与响应的报文大小差异形成放大，从而形成反射放大攻击。在此基础之上攻击者自己或者借助于僵尸网络发送大量仿冒的请求致使受害者收到海量的数据报文造成路径拥堵。

- TCP反射放大攻击：由于防火墙等中间盒子的发展，其在**拦截TCP连接**时并不需要观察完整的三次握手，往往在观察到单向的请求后就开始回复一个响应来实现阻断。同时阻断响应也通常较请求更大，因此攻击者可以通过**故意触发**中间盒子的方式来实现利用TCP实施反射放大攻击
- CDN反射放大攻击：攻击者可以通过精心构造，来发送一些特殊的较小的请求，并让**CDN网络向源站请求较大**的内容，极大的放大流量，对CDN和源站造成很大的负载影响

# 第五章 域名系统安全

## 5.1域名系统工作原理

### 5.1.1域名

**域名由若干个标签**(label)组成，标签之间用点号(.)分隔，标签允许包含的字符：英文大小写字母、数字、短横线

### 5.1.2互联网域名空间

**互联网域名空间**将互联网上的所有可能出现的域名构成集合，按照各自的层级排列，可以放入同一个树形数据结构，这一虚拟的概念称为互联网域名空间。它是一个分布式、层次式的数据库，包括根域名服务器、顶级域名服务器、权威域名服务器。域名数据库中的内容有资源记录和区域。其中资源记录是域名映射关系的表示形式。

DNS 是按照区域组织的，区域将域树上的连续域和子域分组，并将管理权限分配给实体。

### 5.1.2new域名数据库的内容：资源记录和区域

常见的资源类型代号：

- A：IPV4地址；AAAA：IPV6地址；
- NS：权威域名服务器名称；MX：邮件服务器名称
- CNAME：域名别名；SOA：起始授权信息

### 5.1.3互联网域名的解析

在DNS出现之前，互联网使用的是主机上的**host文件**进行名字的解析。

- **递归域名服务器**：全权代理域名解析操作：从根服务器开始，递归解析服务器会逐层向根域名服务、顶级域名服务器和权威服务器发送请求，直到获取到域名对应的IP地址，并将查询结果返回给用户端。递归域名服务器通常也是**本地域名服务器**，主机进行DNS查询时将发送到本地DNS服务器，该服务器通常接近主机，具有名称到地址转换对的**本地缓存**。
- **根服务器**：根服务器是域名系统中域名解析流程的起点，主要作用是提供顶级域名的权威服务器信息。由于UDP报文512字节的限制所以根域名服务器被限制为13个，而现实世界中根域名服务器名称使用[a-m].root-servers.net表示。
- **顶级域名服务器**：顶级域名服务器负责存储与顶级域名相关的信息及其下所有域名的权威服务器信息。在域名解析流程中，顶级域名服务器负责提供权威服务器地址，帮助递归服务器完成定位。
- **权威服务器**：权威服务器提供**域名所有信息**，包括IP地址、邮件服务器等。权威服务器向递归解析服务器回复的信息被视为最终的、可信的解析结果，可以被用于响应用户端的查询请求。每个域名都有多个域名权威服务器，并且尽可能满足地理位置和网络拓扑的多样性

DNS使用的是应用层中TCP或UDP，实现名称和IP地址之间的转换：DNS服务器之间是TCP，客户端与DNS服务器之间是UDP。

### 5.1.4缓存DNS信息

**递归解析服务器**接收到查询的域名响应结果后，可将其中的信息在本地存储一段时间，缓存时间的长度可由权威服务器指定。如果同一网络环境中其他用户所要查询的域名信息已被缓存，递归解析服务器可以直接返回缓存数据，而无需向远程的权威服务器重复发送查询请求。

**负缓存机制**：递归解析服务器可缓存不存在的域名的解析结果（NXDOMAIN），避免短时间内再次执行相同的无效查询，以提高域名解析的速度，避免由频繁的域名解析无效查询导致的网络拥塞。（防止域名查询Dos攻击，避免由频繁的无效查询导致的拥塞）

一旦某个DNS服务器（通常为递归服务器）接收到一个DNS回答，它将*缓存*该映射，并设置TTL。但是如果缓存的条目在TTL到期前就已经过期，那么域名可能无法在Internet范围内被知道。

### 5.1.5 DNS报文格式（有点细 有点难记 需要会解读域名报文）

DNS查询和响应报文，具有相同的格式，用的都是域名协议解析报文，是在域名系统中用于交换信息的数据格式。域名协议报文格式由**报文头部**和**报文体**组成。

报文头部包括：

- **事务序号**：**用于唯一标识报文的唯一性**，域名递归解析服务器经常需要同时与多个权威域名服务器进行交互，为了区分不同会话的应答响应内容，域名协议报文需要一个唯一的标识符将相应报文与查询请求相互匹配
- **标志字段：用于标记当前报文的基础属性**，指明查询/响应标志、操作码、授权回答标志、递归查询标志等
- **四个计数字段：QDCOUNT、ANCOUNT、NSCOUNT、ARCOUNT**，有助于加速域名软件对于域名协议报文的解析与处理。

报文体对应报文头中的四个计数字段，包括四个区域：

- 问题区域QUESTION SECTION：指定用户要查询的目标域名以及资源记录类型
- 应答区域ANSWER SECTION：回答满足被查询域名和资源记录的权威应答
- 授权区域AUTHORITY SECTION：一般包含类型为NS的资源记录，指定域名的权威服务器名称
- 附加区域ADDITIONAL SECTION

## 5.2域名系统典型攻击

**域名协议在设计之初并未考虑任何安全和隐私问题。域名系统中的查询和响应都采取基于UDP协议的明文方式进行传输。**

### 5.2.1 DNS劫持攻击

攻击目的：通过篡改用户查询域名的资源记录内容，将用户的域名解析请求流量**重定向**到攻击者控制的**恶意服务器**上，导致用户希望访问的目标网站或网络服务被**替换为攻击者控制的恶意网站或服务器**。

攻击原理：域名劫持攻击安全风险的根源在于域名解析交互过程中消息内容**缺乏完整性与真实性保护**，即客户端在接收到应答响应报文内容之后，无法有效地检查响应内容的正确与否，因此不得不被迫接受攻击者篡改后的资源记录内容

DNS劫持可以发生在域名解析的各个步骤，主要分为如下几类：

- **本地劫持**：修改用户设备DNS配置，将特定域名解析到攻击者指定的IP地址上
- **递归解析服务器劫持**：控制递归服务器返回攻击者控制的域名服务器或IP地址
- **权威服务器劫持**：攻击者可以利用安全漏洞或攻破域名管理者的账户来篡改权威服务器的域名资源信息。
- **中间人劫持**：攻击者**截获域名解析请求**并篡改其中包含的解析结果

攻击危害：网络钓鱼、信息窃取、恶意软件传播、服务中断和通信干扰

### 5.2.2 DNS缓存污染攻击

攻击目的 ：篡改目标域名在**缓存**中的资源记录，以进一步实施网络钓鱼、传播恶意软件或收集用户敏感信息等一系列活动。

攻击原理：缓存污染攻击安全威胁的根源同样也是域名协议报文**缺乏消息完整性验证的检查**。攻击者通过发送精心构造的DNS响应报文来**欺骗递归解析服务器**，使其将错误的解析结果存储在缓存中。一旦递归解析服务器的缓存被污染，使用相同递归解析服务器的互联网用户在解析该域名时均会被错误地重定向到攻击者控制的服务器地址。

#### 攻击模型

使用旁路注入的方式：

- 攻击者并不位于域名解析链路上，无法直接嗅探和修改报文
- 攻击者想要注入一个伪造的响应，令递归域名服务器接受并写入缓存

如何让递归域名服务器接受伪造响应？与递归服务器发出的请求相匹配

#### 攻击流程

- 当用户端发起域名查询请求后，递归解析服务器依据域名空间层级结构，逐级向权威域名服务器发送查询请求。
- 在此期间，攻击者向递归解析服务器发送精心构造的恶意DNS响应报文，其中包含伪造的域名资源记录。
- 如果攻击者伪造的响应能够**先于**权威服务器返回的合法响应到达递归解析服务器，**并且能够被递归解析服务器接受**，使其将错误的解析结果存储在缓存中

#### 构造响应报文（有点重要）

递归域名服务器检查响应时会看：IP地址是否匹配、目标端口是否匹配、TXID是否匹配、问题区域是否匹配

1. IP地址匹配：源地址为权威服务器地址、目的地址为递归域名服务器地址，均可伪造
2. 端口匹配：源端口为53（DNS默认服务端口）、目的端口为递归服务器的**请求源端口（无法伪造）**
3. TXID匹配：响应的TXID（事务序号）要**等于请求TXID（无法伪造）**
4. 问题区域匹配：响应问题区域 = 请求问题区域（可以伪造，通过自问自答的方式）

攻击者通过自问自答的方式，使得问题区域相匹配，但是需要猜解请求源端口、请求TXID。在域名协议报文格式中，上述两个字段均为16位，暴力枚举的空间为$ 2^{16}*2^{16} $，几乎不能实现。



### 5.2.3 DNS反射放大攻击

DNS反射放大攻击是**分布式拒绝服务攻击**（DDoS）的一种常见方式。

攻击原理：DNS反射放大攻击的根源在于网络中存在大量**开放的域名递归解析服务器**，这类服务器未能严格限制服务用户的目标范围，使其公开暴露在所有攻击者的视野中。攻击者可以借助伪造源地址的方式，冒充受害者向开放递归解析服务器发起查询请求，随后利用对外开放的递归解析服务器实现对攻击流量的放大。

攻击流程：

1. 攻击者首先寻找大量开放的递归解析服务器，并向这些递归解析服务器发送伪造的**查询请求**报文，将查询的源IP地址设置为受害者的IP地址。
2. 大量递归解析服务器返回的响应报文将被发送给受害者，占据受害者服务器的网络带宽。
3. 攻击者会选择查询**响应数据包很大的资源记录类型**。这种方式可以使得受害者接收到的响应报文大小远超攻击者需要发送的查询请求报文大小，起到巨大的反射放大的效果。

### 5.2.4 DNS重绑定攻击

DNS重绑定攻击（DNS Rebinding）是一种是一种典型的利用域名解析机制发起其他网络攻击方法。

攻击原理：攻击者通过操控域名解析的**应答响应报文**，规避浏览器的**同源防御策略**，进而非法获取受害者内网站点信息的一种攻击方法。DNS重绑定攻击的适应场景主要是受害者处于一种安全受控的**内网环境**，攻击者难以直接从外部网络环境对受害者内网的资源进行访问。

攻击流程：

1. 攻击者首先并引导受害者访问其控制的**恶意域名**。
2. 随后攻击者控制的恶意域名服务器将该域名指向一个公开可访问的主机地址。并将恶意域名资源记录的**有效期TTL设置为极短**。
3. 恶意网站中返回包含JS的恶意代码。
4. 在恶意域名的资源记录过期后，攻击者控制的恶意域名服务器将该域名解析为**内部网络的主机地址**。浏览器认为整个网络访问过程属于同一个域名，并允许恶意JS代码访问受害者内部网络环境（反弹shell）。

## 5.3 DNS常见安全防护措施（待补充完整DNSSEC）

基于**随机化**的安全防护方案：

- **源端口和事务序号随机化方案**：防止DNS缓存污染
- **域名大小写编码随机化**：防止中间人劫持
- **DNS Cookie 方案**：在报文附加部分添加DNS cookie（随机生成的64位），防止中间人劫持

基于**加密**的安全防护方案致力于完善**认证机制**和消息机密性，旨在从根本上解决由于DNS明文传输引发的嗅探监听风险：

- **DoT（DNS over TLS）**：使用TLS协议来加密域名解析流量，用户端首先与递归域名服务器建立TLS连接，将DNS查询封装在TCP中并发送，递归服务器解密后再进行查询，最后同样加密后传给用户端。
- **DoH（DNS over HTTPS）**：在HTTPS会话封装DNS请求和响应，可以与HTTPS协议共享443端口来执行域名解析
- **DoQ（DNS over QUIC）**：基于QUIC协议，它是一种基于UDP的安全协议。
- **DNSSEC（Domain Name System Security Extensions）**：用户端在接收资源记录前会**额外验证DNSSEC签名**，只有通过验证才会被接收。



# 第六章 Web系统安全与防御

## 6.1 Web系统

Web系统包括浏览器（即Web客户端）、目标服务器（即Web服务器）、以及二者之间的核心交互。

- Web客户端：例如Edge、Chrome等
- Web服务器：用于存储、处理和提供 Web 页面和其他Web 内容以响应Web客户端的请求。
- HTTP/HTTPS：定义了Web 浏览器和Web服务器之间请求和响应的消息格式和规范

### 6.1.1Web浏览器

功能：使得样式与内容分离，让网页开发者可以更容易地控制网页的外观和布局

安全风险：在**CSS中**注入恶意代码或规则，改变网页外观，诱导用户执行恶意操作。

- 遇到语法错误、非标准的CSS语法、或者处理CSS中的转义字符出现错误，将会**继续解析**，并在**下一个语法匹配的括号处重新开始**，这种解析**重新同步逻辑**可能会被攻击者利用而解析了恶意CSS规则集。
- 攻击者可以利用CSS解析器版本的差异，使低版本解析器在解析高版本CSS规则时出现错误，利用透明样式等混淆用户或诱导用户点击

### 6.1.2 JavaScript

功能：是一种开放的、解释性的**跨平台脚本语言**，主要用于在网页上**实现交互式功能**，使得网页不再是静态的展示页面，而是具有复杂功能和交互性的页面

安全风险：

- 脚本注入：攻击者在网页中插入恶意 JavaScript 代码，利用用户对受信任网站的信任，使**恶意脚本在用户的浏览器中执行**
- 点击劫持攻击：攻击者在网页上层创建一个**透明或者隐藏的框架**，使用JavaScript将恶意链接添加到页面上，当用户以为自己点击的是正常页面时，实际上点击的是JavaScrip代码添加的恶意链接
- 拒绝服务攻击：利用JavaScript死循环、间歇式释放CPU资源、不断弹出新窗口
- 若没有对所有**控制字符**都进行转义处理，或者网页设计存在**逻辑错误**，或者没有正确处理敏感数据，都会导致用户敏感数据的泄露。

### 6.1.3 插件

功能：通常由**第三方开发者**开发，并且可以被用户**自由选择**性地安装和启用的浏览器的额外功能或特性。

最常见的激活方式为：**使用type参数标签指明所访问的文件类型**，当浏览器显示时会与插件类型进行匹配，若匹配则转给插件进行处理；若未匹配会提示去下载插件，或者浏览器检查HTTP响应报文中的Content-Type头或URL中文件的后缀来确定所要显示的文件的类型。

安全风险：

- 隐私泄露：插件会收集用户的浏览历史、搜索习惯、甚至个人信息
- 恶意插件：部分插件可能被设计为恶意软件
- 权限过度：插件在安装时可能会要求用户授予过多的权限，如访问浏览器所有网站的数据。
- 更新和维护问题：插件长时间不更新可能使用户面临风险

### 6.1.4 Web服务器（比较细 后续还需要再回顾）

接收来自客户端（如浏览器）的HTTP/HTTPS请求，包括请求特定网页或资源的URL，可能涉及读取文件、执行脚本、查询数据库等操作，将请求处理的结果生成HTTP响应并发送回客户端，以便客户端显示请求的内容。

**持续对话**：Web服务器的持续对话是一种机制，允许客户端与服务器之间建立一种持久的连接，以便在单个连接上发送多个HTTP请求和响应，通过Connection: keep-alive来实现。

**分段数据传输**：分段数据传输是指Web服务器将响应的内容分成一系列数据块，逐块发送给客户端，而不需要等整个响应内容准备就绪后再发送，通过设置Transfer-Encoding: chunked来实现。安全风险：过多的数据分段可能导致浏览器代码中的整数溢出问题，或者利用设置在 HTTP 响应头中的 Content-Length 和**分块长度不匹配**的方式造成浏览器展示的混乱

**Web缓存**：Web缓存器也称为代理服务器，代表初始的Web服务器来缓存和传递经常请求的Web页面或资源。代理服务器可以缓存已经获取的内容，并在后续请求中直接提供缓存的副本，从而提高整体性能和用户体验。安全风险

**认证**：Web服务器的认证是对客户端的身份进行验证，以确保其有权限访问服务器上存储的受保护的资源或服务。



### 6.1.5 统一资源定位符URL

URL是一种特定格式的字符串，用于标识互联网资源的地址。

URL的格式通常如下：**协议://主机名[:端口号]/路径/[?查询字符串]**

- 协议：指定了访问该资源需要使用的协议
- 主机名：标识了资源所在的主机，可以是域名或IP地址
- 端口号：可选，表示了用于与服务器通信的端口
- 路径：指定了资源在主机上的位置
- 查询字符串：可选，指定向服务器传递的额外参数

### 6.1.6 HTTP(*)

#### HTTP的工作方式

1. Web客户端发送一个HTTP请求到Web服务器，请求中了要获取的资源的信息
2. 服务器接收到请求后，根据请求的内容进行处理，然后生成一个HTTP响应，响应中包含了响应头部信息，以及请求的结果或资源。
3. 服务器将响应发送回客户端，客户端接收到响应后进行解析，然后根据响应中的数据进行相应的处理，例如显示网页内容或执行其他操作。

一个应用程序可能既是客户端又是服务器。例如，**HTTP代理服务器**。

#### HTTP请求报文

HTTP请求报文分为三个部分：请求行、请求头、请求体

- 请求行：请求的方法、所请求资源的路径和HTTP的版本
- 请求头：包含了一系列**键值对**，用于传递请求的附加信息
- 请求体：用于传递请求中需要发送的数据，如表单数据或JSON数据等

HTTP提供了**方法字段**来对不同请求的目的进行区分,包括：GET，POST，OPTIONS，HEAD，PUT，DELETE等，最常见的是GET和POST

- GET：从服务器请求特定资源，用于检索各种类型的资源，例如HTML 页面、图像、视频和数据等
- POST：用于向服务器提交数据，提交的数据包含在请求体中，通常用于创建或更新资源。

HTTP中的**请求头**用于传递关于请求的相关信息。请求头中的每一项都是键值对，帮助服务器了解客户端的要求和处理请求的方式。

请求体主要用于传递请求中**需要发送的数据**，其内容与请求的目的有关。请求体可以包含表单数据、JSON数据、XML数据、甚至二进制数据等。请求体的格式通常由请求头的Content-Type字段指定，其内容长度由请求头中的**Content-Length**指定

#### HTTP响应报文

HTTP响应报文是服务器向客户端发送响应时使用的数据格式。与请求报文类似，它也由三个部分组成：**状态行、响应头和响应体**。

**HTTP状态码**用于表示请求的处理结果的**三位数字代码**，用于标识HTTP请求的处理状态，并为客户端提供有关请求处理结果的信息。根据表示的含义，状态码被分为五类，分别以数字1~5开头。

- 1xx信息响应：已被接收正在处理
- 2xx成功响应：客户端的请求被成功接受并处理
- 3xx重定向响应：表示重定向
- 4xx客户端错误响应
- 5xx服务器错误响应：服务器处理请求时发送错误

与请求头类似，**HTTP中的响应头**用于传递关于响应的相关信息,响应头中的每一项也是键值对，用于服务器向客户端提供有关响应的上下文信息，以便让客户端进行相应的处理。

**HTTP响应体**的主要作用是服务器向客户端提供请求的资源或返回请求执行后的结果。它通常包含服务器返回给客户端的实际内容，可以是HTML、XML、JSON、图像等各种格式的数据。

与请求体不同的是，服务器可能会对响应体**采取某种压缩或编码方式**，以减少数据传输的大小，提高传输效率。常见的压缩方式包括gzip，br和 deflate等。

#### HTTP状态管理与Cookie

HTTP本身是无状态的,仅规定了服务端和客户端之间的通信方式，而并未要求双方记录必要的信息，但用户认证、个性化内容、会话管理等功能都需要服务器端通过某种机制记录客户端的历史行为。为了满足这些新的需求，需要在无状态的HTTP上引入**状态管理机制**。

常见的状态管理机制包括：

- 服务器端会话管理：在**服务器端**存储跟客户端的会话数据，并将会话**标识符**发送给客户端，来实现用户会话的持久性
- URL重写：将**会话标识符**或其他状态信息**附加在URL**中，通过URL参数传递和维护用户状态信息
- HTTP Cookie：存储在**用户浏览器中**的一小块数据，当用户再次访问该网站时，浏览器会自动地将存储的Cookie数据发送给服务器。服务器根据Cookie值确定用户身份，进而为用户提供个性化服务
- 隐藏表单字段：状态有时通过隐藏的表单字段来维护，这种方式允许在表单提交时连同用户提交的其他表单数据一起发送给服务器端

服务器可以使用 Set-Cookie 头向浏览器发送带有特定属性的 Cookie，格式如下：

Set-Cookie: <name>=<value>[; <property-name>=<property-value>]...

多个 Cookie 之间使用分号和空格进行分隔。基于客户端发送的Cookie信息，服务器可以实现会话管理、用户识别和个性化体验等功能。

## 6.2 Web系统常见威胁

### 6.2.1 身份假冒攻击

通过操控网站的**域名解析过程**可以实现这种假冒Web网站的攻击，Web系统最初的HTTP协议也没有提供可靠的真实性验证机制，攻击者可以通过在链路上的注入**虚假的HTTP响应**把用户的HTTP访问重定向到伪造的Web网站

### 6.2.2 网络流量监听和中间人

- 被动攻击：未经授权的网络监听被称为被动攻击，攻击者可以监听所有局域网中或附近的网络流量。
- 主动攻击：攻击者不仅可被动地监听网络流量，还可以主动地注入假冒的网络流量、重发甚至修改通信双方的流量、丢弃合法的流量等（充当中间人）

### 6.2.3 Web客户端和Web服务器端的系统入侵攻击

攻击者利用客户端和服务器端配置或实现中的**安全漏洞**入侵系统，获取用户的敏感信息，或者对系统的软件或数据进行破坏：

- 对客户端软件浏览器来说：允许可执行的内容、数据和代码混合使得客户端的安全防护变得异常复杂。
- 对服务器系统来说：对Web服务器系统的入侵则更加普遍。

### 6.2.4 拒绝服务攻击

攻击者通常通过大量看似合法的请求增加Web网站的工作负荷，使得正常用户无法访问。

### 6.2.5 安全机制概要

- 针对网站假冒、监听和中间人攻击：使用HTTPS解决，使用认证、加密和完整性保护的方法
- 针对Web服务器入侵：使用Web应用防火墙
- 针对拒绝服务攻击：使用内容分发网络CDN
- 针对客户端浏览器的攻击：使用沙箱机制，隔离网页或插件的运行环境，以确保恶意代码
  无法对用户系统造成危害。同时限制资源访问、监控异常行为。

#### 同源策略

#### 浏览器插件的安全规则

#### HTTPS协议

#### Web PKI 和公钥整数基础

Web公钥基础设施（Web PKI）是用于保护Web浏览器和Web服务器之间通信安全的一套系统、政策和程序，包括签发证书的证书权威机构（CA），以及CA提供的证书状态服务、Web服务器和浏
览器实现的TLS/SSL协议栈等

### TLS协议工作原理

TLS 协议协议栈包括多个子协议，可以分为**两层**。

- **顶层**包括握手协议、更改密码规范和警报协议，主要完成**身份认证**、TLS各种密码算法和相关参数的**协商**和**错误报告**等
- **下层**完成TLS 数据的封装、编码、加密和解密、完整性验证、压缩等操作，最终完成数据的传输 。

### TLS握手协议

TLS 客户端和TLS服务器之间从握手协议（Handshake Protocol）开始，通过握手过程建立安全信道、完成密码算法和密钥的协商、身份认证等功能，以后所有的通信都基于这些参数保护应用层的流量实现安全通信。**握手过程大概完成四项活动**

- 交换安全能力，协商密码算法和相应的参数；
- 通过公钥证书或其他方式验证对方身份
- 协商一个共享的主密钥，用于产生后续安全会话的其他共享密钥
- 验证握手过程中所有消息的完整性

工作流程如下：

1. 客户端发送ClientHello消息：客户端向服务器发送 ClientHello 消息发起 TLS 连接，其中包括客户端的**安全能力**（支持的协议版本、密码算法和所支持的扩展）。
2. 服务器发送ServerHello消息 ：TLS 服务器发送ServerHello消息，其中包括服务器所选择的各项参数。
3. 服务器发送Certificate消息：Certificate消息包括一个证书链的多个证书，包括服务器证书、签发该服务器证书的CA证书。收到证书链后，客户端只有能够从本地预置的可信CA根证书成功**构造一个完整的证书链**，才能证明该证书是可信CA所签发的。
4. 服务器发送ServerKeyExchange消息：包括密钥协商算法所需的额外的数据，其内容因选择的密钥交换算法不同而有很大差异。
5. 服务器发送CertificateRequest消息：只有服务器要求客户端使用公钥证书来完成身份认证时，服务器才会发送这一消息。
6. 服务器发送ServerHelloDone 消息：通知客户端，服务器已经把必要的消息发送完毕，之后等待客户端发来的消息以完成握手过程。客户端收到这个消息之后，应该验证服务器发来的证书的合法性，并判定 ServerHello 消息的有效性。
7. 客户端发送客户端证书消息 Certificate：只有服务器要求客户端发送证书时（即收到CertificateRequest），客户端才会发送这一消息。该消息应该包括一个客户端的证书链，使得服务器可以完成客户端证书的验证。
8. 客户端发送的ClientKeyExchange：客户端为了完成密钥协商而向服务器发送的相关参数信息。
9. 客户端发送CertificateVerify消息：用于证明客户端的确拥有上述（7）中发送的客户端证书（即有该证书相应的私钥）
10. ChangeCipherSpec 消息：客户端和服务器**都可以向对方发送该消息**，表明自己**已经完成**了各种连接参数、相关密钥的生成，以后的所有的消息都是加密的了。ChangeCipherSpec是一个独立的子协议，不属于握手子协议。
11. Finished 消息：Finished 消息在 ChangeCipherSpec消息之后，是加密传输的第一条消息。这一消息的主要意义在于验证整个握手过程的完整性，以防止中间人攻击



除了握手协议以外，还有

- 记录层协议：TLS协议的外壳，记录层协议是TLS协议的外壳，负责应用层数据和TLS其他子协议（比如握手协议）的数据分段、加密和解密、完整性验证和数据压缩和解压缩等，所使用的密码算法、参数等相关信息都是在握手协议交互中共同协商的。
- 告警协议：告警协议用于向对方发送一个协议状态的异常事件，比如检测到数据可能经过中间人的修改、通知对方终止当前的会话。告警消息包括一个告警级别和关于告警的描述代码，告警级别可分为警告和致命两种。

### CDN内容分发网络

**内容分发网络（CDN）**是一种分布在**不同地理位置的代理服务器**组成的网络，通过把Web网站的内容分发到离用户更近的代理节点上，从而**加速**用户对网站内容的访问，CDN已经成为重要的互联网基础设施。

CDN的核心功能之一是**在多个地理位置的服务器上缓存内容**。当内容提供者（如网站所有者）决定使用CDN服务时，原始网站的静态内容（如HTML文件、图片、视频、CSS样式表等）被复制并分发到CDN 厂商各地的多个服务器上，这些服务器通常被称为**缓存服务器或边缘服务器**。之后，当用户请求特定内容时，可以从离用户最近的服务器上快速获取，从而显著减少加载时间，提高用户体验。

CDN 的主要功能包括以下五个方面：

- **降低网络延迟**：用户的访问被调度到离用户最近的节点
- **过滤恶意的Web访问**：CDN可以像**Web 应用防火墙**一样实现访问控制和基于规则的恶意流量**过滤功能**，保护CDN后面的服务器
- **抗拒绝服务攻击**：CDN节点拥有**较高带宽**，且攻击者流量被分散到多个节点上，从而不再对网站的可用性构成威胁
- 均衡网络负载：CDN厂商可以根据不同节点的负载情况动态调度用户的访问，缓解网络拥塞
- 提高网络可靠性：在一个节点出现故障时、或者在一个节点受攻击时，用户可以使用其他节点的服务



# 第七章 邮件系统安全

## 7.1 邮件系统工作原理(待补充)

- 邮件用户代理MUA：编写、发送、接收和管理电子邮件。
- 邮件提交代理MSA：负责接收电子邮件，并将其投递到 MTA。
- 邮件传输代理MTA：负责完成与其它 MTA 之间的邮件投递和接收。
- 邮件投递代理MDA：负责将 MTA 接收到的邮件放置到用户的邮箱中。

### 7.1.1 SMTP协议

简单邮件传输协议（Simple Mail Transfer Protocol, SMTP）是最常用的电子邮件**投递协议**，是一种**面向连接、基于文本**的协议，协议工作在 TCP 协议之上，标准端口号为25。

MTA使用SMTP发送邮件的主要流程如下：

1. 连接建立阶段：发件MTA与收件MTA建立**TCP连接**后，收件MTA发出**220 Service ready**来指示客户端开始建立 SMTP 连接。之后，发件人的 MTA会发送**HELO命令**，并附上**发件人的主机名**来标识发送方的身份
2. 邮件发送阶段：发件MTA首先使用 **Mail From** 命令来传递发件人的邮件地址，并会通过**Rcpt To**命令将收件人邮件地址告知收件MTA。发件人的MTA将发出 **DATA 命令**，并传递电子邮件的正文。
3. 连接释放阶段：等到所有邮件内容发送完毕后，发件人的 MTA 会发出**QUIT 命令**，表明打算退出 SMTP 通信。之后，收件人的MTA会回复**221 Bye，并关闭SMTP连接**。

SMTP 是一种“可靠”的传输协议，如果服务器无法投递邮件，它通常会生成一封“退信通知”返回给发件人：使用电子邮件状态码+说明的方式

MAIL FROM和FROM的区别：

- 信封上的发件人 (Envelope Sender / **MAIL FROM**)：在 SMTP **传输层**（由于用户不可见，所以也叫“不可见发件人”）
- 信纸上的发件人 (Header **From**)：在邮件内容的数据包里，显示给用户看的

### 7.1.2 POP3协议

邮局协议 (Post Office Protocol, POP)，POP3 是它的第三个版本，工作在 **TCP 协议**之上，标准端口号为 110。

采用**离线邮件处理**，使用POP3的电子邮件客户端每隔一段时间就会从邮件服务器中下载所有没有阅读过的电子邮件，但会**阻碍**了多个客户端的电子邮件**同步**。下载电子邮件前通常无法得知电子邮件的具体内容。

### 7.1.3 IMAP协议

- 允许客户端**在线操作和阅读**邮件服务器中的电子邮件，支持邮件客户端决定是否收取电子邮件或者直接删除电子件。
- IMAP4协议**不会自动删除**已从邮件服务器中下载的电子邮件，并且允许多个邮件客户端同时访问同一个邮箱
- IMAP4所采用的**分布式存储邮件机制**解决了服务器和客户端同步性的问题 。
- IMAP4客户端能够记录用户在本地的操作并传递给IMAP4服务器，比如有新邮件到达、标记已读、移动文件夹等

### 7.1.4 MIME协议

多用途互联网邮件扩展：用于在互联网上传输多媒体和文本信息。MIME 扩展了电子邮件标准的能力，允许用户在电子邮件中发送非文本附件，比如图片、视频、音频文件以及其他文件格式





## 7.2 邮件系统常见攻击

### 7.2.1垃圾邮件与钓鱼攻击

- 垃圾邮件：通常是指发送给大量用户的未经请求的电子邮件
- 钓鱼邮件：攻击者通过伪装成合法或可信的机构、组织或个人发送电子邮件，以欺骗接收者提供敏感信息

### 7.2.2 恶意软件

恶意软件分类树：

- 依赖宿主：包括陷门 (Trapdoors)、逻辑炸弹 (Logic bombs)、特洛伊木马 (Trojan horses) 和病毒 (Viruses)
- 独立运行：以自我运行和传播，包括蠕虫 (Worm) 和僵尸程序 (Zombie)

恶意软件简介：

- 病毒：是一段代码，必须插入到宿主程序（如 OS 或应用程序）中才能运行和传播 。
- **特洛伊木马**：伪装成合法软件，不自我复制，但破坏性强，通常作为后门允许攻击者远程控制系统。
- 蠕虫：不需要宿主，能自我复制并向其他机器传播



### 7.3.3 Rootkie隐藏技术

它的核心目标不是破坏，而是**“隐藏”**——隐藏进程、文件、网络连接以及其他恶意软件 。

权限分级：

- **Ring 3 (用户模式)：** 运行普通应用程序，信任度最低 。
- **Ring 0 (内核模式)：** 运行操作系统内核和驱动程序，拥有最高权限，可以直接访问硬件 

Rootkit 的发展史就是从简单的文件替换（第一代）向内核级攻击（Ring 0）演进的过程 。

Rootkit 的攻击技术详解：

Ring3 rootkie：运行在用户空间，主要通过欺骗应用程序来隐藏信息。

- IAT hooking (导入地址表挂钩)：
  - 每个 PE 文件（可执行文件）都有一个 IAT 表，记录了它调用的 API 函数的内存地址 。Rootkit 修改这个表中的地址，将其指向恶意代码
  - 程序调用API时，不是跳转到真正的系统函数，而是跳转到 Rootkit 的 Hook 函数，Rootkit 过滤掉不想让用户看到的文件后，再把结果返回给用户 
  - 缺点： 容易被检测，且对于采用“延迟绑定”(Late binding) 的程序可能无效 。
- Inline Function Hooking (内联挂钩)：
  - 直接修改内存中目标函数的前几个字节（Preamble）
  - 攻击者将**函数开头的指令**覆盖为 JMP Hook（跳转指令），强行把执行流劫持到恶意代码 。这种方式比 IAT Hook 更强大，因为它不依赖于地址表 。



Ring 0 (内核层) Rootkit：运行在系统核心，极难检测，可以完全控制操作系统。

- SSDT Hooking (系统服务描述符表挂钩)
  - SSDT 表映射了**系统调用号**与**内核函数**的对应关系。Rootkit 将 SSDT 表中的函数指针替换为恶意驱动的地址
  - 防护与绕过： 现代 Windows将 SSDT 所在内存设为**只读**。但Rootkit 会通过修改 CR0 寄存器来强行关闭内存写保护，从而篡改 SSDT
- IRP Hooking (I/O 请求包挂钩)
  - 拦截发送给驱动程序的 IRP 数据包。Rootkit 可以在文件系统驱动层拦截查询文件的请求，从中删除要隐藏的文件名，然后将“干净”的列表返回给上层
- DKOM (直接内核对象操作)
  - 这是一种高级技术它不通过 API，而是直接在内存中修改操作系统的数据结构



## 7.3 邮件身份验证机制（难）

### 7.3.1 SPF发件人策略框架

**核心作用：** 防止 IP 地址欺骗。它验证发送邮件的服务器 IP 是否获得了域名的授权。

- 域名所有者在 DNS 中发布一条 SPF TXT 记录，列出所有被允许代表该域名发送邮件的 IP 地址或服务器 
- 当收件方收到邮件时，会检查发件人 IP 地址是否在 SPF 记录的允许列表中。如果匹配，则验证通过

SPF中常见的匹配规则：

- a：表示允许当前域名的 A 记录所对应的IP发送电子邮件
- mx：如果发件人域名的MX记录的 IP 地址与该匹配机制指定的IP 地址匹配，则SPF 检查通过。
- ip4 ip6：这个匹配机制也可设置允许代表域名发送电子邮件的 IP 地址
- include：允许将SPF 记录指向另一个域名
- exists：如果该匹配机制指定的域名存在 A 记录，则SPF 检查通过
- all：这个匹配机制表示所有 IP 地址，其肯定会被命中

### 7.3.2 DKIM域名密钥识别邮件

**核心作用：** 防止邮件内容篡改和伪造发件人。它利用数字签名技术确保邮件在传输过程中保持完整性

- 签名：发件服务器使用私钥对**邮件标头**（如 From, Subject）和**正文**进行哈希计算并签名，生成 DKIM-Signature 标头附加在邮件中
- 验证：收件服务器通过 DNS 查询发件人的公钥，解密签名并验证哈希值。如果一致，说明邮件未被篡改且确由该域名发送

### 7.3.3 DMARC (基于域的消息认证、报告和一致性)

**核心作用：** 解决 SPF 和 DKIM 的缺陷（它们不验证用户看到的 `From` 地址，且未规定验证失败后的操作），并将三者结合起来 

**核心机制**：标识符对齐 (Alignment) DMARC 要求邮件的 SPF 验证身份（Mail From）或 DKIM 签名域（d=domain）必须与**用户看到的** 发件人地址 (Header From) 保持一致（或为子域名关系）。只有这样，才算 DMARC 验证通过 。

人话：验证Mail From要与From保持一致

**主要功能**：

- 策略执行：告诉收件方，如果 SPF 和 DKIM 都失败了（或者标识符不对齐），该怎么处理邮件。
- 反馈报告：允许发件人接收验证失败的报告，以便监控域名被滥用的情况

## 7.4 邮件身份验证绕过攻击

### 7.4.1 三种经典的场景

- 共享MTA：攻击者和受害者使用同一个邮件服务商，攻击者通过服务商合法的 MTA 发送邮件，但修改 Mail From 或 From 为 alice@a.com，从而假冒alice进行发送电子邮件。
- 直接MTA：攻击者**自己搭建邮件服务器**，直接向收件人的 MTA 发送邮件，随意指定 `Mail From` 和 `From`
- 转发MTA：利用合法的邮件**转发服务**， 攻击者发送假冒邮件给转发服务器，转发服务器自动将其转发给最终受害者。攻击的前提是电子邮件转发服务器（a.com）在没有严格验证电子邮件真实性的情况下对所有转发的电子邮件添加DKIM 签名

### 7.4.2 身份验证标识符不一致攻击

攻击者利用**“MTA 验证的身份”**与**“用户看到的身份 (MUA 显示)”**不一致来实施欺诈。

- 空 Mail From 攻击
  - 协议允许 Mail From 为空（用于退信）。SPF 规定此时应验证 **HELO 域名**
  - 攻击者故意设置其为空， HELO 域名为攻击者控制的域名，结果： MTA 验证攻击者的域名通过，但邮件客户端显示伪造的 From: alice@a.com
- 多 From 标头攻击（多个from多个地址）
  - 虽然标准禁止，但某些系统接受含有两个 From 头的邮件
  - `From: <fake@attack.com>` (放在前面，MTA 用它做 DMARC 验证 -> 通过
  - `From: <alice@a.com>` (放在后面，MUA 可能会展示这个给用户看
  - 实际上是验证了攻击者的服务器的身份，用户却看到了受害者的名字，成功伪造发件人
- 多邮件地址攻击（一个from多个地址）
  - `From` 字段包含多个地址
  - 类似多标头，MTA 和 MUA 可能分别抓取不同的地址进行验证和显示，导致欺骗成功
- 不存在子域名攻击
  - 利用 SPF 对不存在域名的处理机制
  -  不存在的域名没有 SPF 记录，结果返回 `none`，许多邮件网关不会拒绝 `none` 结果的邮件，从而放行 。

### 7.4.3 身份验证结果注入攻击

原理：邮件服务器执行 SPF 和 DKIM 验证的组件会将**结果**生成一个 `Authentication-Results` 头部，然后传递给 DMARC 组件进行最终裁决。攻击者试图篡改或伪造这个头部而不被检测到 。

#### DKIM验证结果注入攻击

攻击者操纵 DKIM 签名中的 `d=` 标签（签名域），利用特殊字符制造解析混乱

例如：攻击者使用自己的私钥**生成 DKIM 签名**，但在 `d=` 标签中嵌入包含括号 `(` 的畸形域名。例如：`d=a.com(.attack.com` ，这个时候就会存在解析差异：

- DKIM组件：可能会正常处理这个长域名，通过 DNS 查询攻击者控制的域名（ `attack.com` 相关记录）的公钥。因为私钥也是攻击者的，所以 **DKIM 签名验证通过**
- DMARC组件：在读取验证结果时，将 `(` 之后的内容视为**注释**并忽略。因此，DMARC 认为签名的域名是 `a.com`（受害者域名）

**结果：** DMARC 认为邮件是由 `a.com` 签名的，且与发件人地址（From: alice@a.com）一致，从而**通过 DMARC 验证**，放行了伪造邮件 。

#### SPF验证结果注入攻击

攻击者操纵 `Mail From` 命令中的地址，利用特殊字符欺骗 SPF 和 DMARC。攻击者在 `Mail From` 中构造一个包含单引号 `'` 的畸形地址。例如：`alice@a.com'@a.attack.com` ，导致解析差异：

- **SPF 组件：** 通常从右向左解析，或者识别最后一个 `@` 之后的部分，即验证 `a.attack.com`。因为 IP 是攻击者的，**SPF 验证通过** 。
- **DMARC 组件：** 在解析验证结果以进行对齐检查时，可能会在遇到单引号 `'` 时停止解析，或者将单引号后的内容视为字符串。因此，DMARC 提取出的域名部分变成了 `a.com`。

### 7.4.4 DKIM 重放与欺骗攻击

DKIM使用数字签名来防止邮件内容被篡改但仍有两大缺点：DKIM不能防止重放攻击、DKIM允许攻击者将额外的电子邮件标头，甚至邮件正文，添加到被签名保护的消息中。

- DKIM 重放
- 邮件标头欺骗
  - DKIM 签名只保护 `h=` 标签里列出的标头。如果 `Subject` 没有被签名，攻击者就可以修改邮件主题。
  - 例如，原邮件有一个 `Subject`，攻击者再添加一个 `Subject`。如果邮件客户端优先显示第二个 Subject，欺骗就成功了，而 DKIM 签名依然有效
- 邮件正文欺骗
  - 利用 `l=` 标签（长度标记）。如果 DKIM 签名指定只验证正文的前 1000 字节
  - 攻击者在 1000 字节之后追加恶意内容，同时修改 `Content-Type` 边界，把原始正文隐藏掉，让邮件客户端只显示攻击者追加的恶意部分 







# 第八章 防火墙

## 8.1P^2DR安全模型

- 安全策略policy
- 防护protect：防火墙
- 检测detection：入侵检测系统
- 响应response

## 8.2防火墙概述



缺陷：

- 无法对抗旁路攻击
- 不完全透明，可能带来传输延迟、瓶颈及单点失效
- 不能防范端端加密通信
- 内部威胁的盲区

### 8.2.1 包过滤防护墙

根据每个接收和发送的数据包的网络层或传输层的信息应用安全过滤规则，然后决定转发或者丢弃该数据包

优点：

- 检查规则相对简单，检查操作耗时极短，执行效率非常高
- 实现对用户是透明

缺点：

- 缺乏应用层感知：**只看头部，** 它无法检查数据包的**实际内容**，攻击者可以通过将恶意代码隐藏在允许的端口和协议
- 无法进行状态跟踪：包过滤防火墙无法跟踪网络连接的**会话状态**
- 配置复杂且容易出错
- 无法防御更高级的攻击：对于源 IP 不断变化的分布式拒绝服务 (DDoS) 攻击，它作用有限

### 8.2.2 状态过滤防护墙

防火墙不仅检查数据包的头部信息（如源地址、目标地址、端口号等），还跟踪和记录网络连接的状态，确保数据包在符合预期的会话中进行传输。

优点：

- 具有状态感知能力
- 管理复杂度降低：只需定义出站规则，入站的合法返回流量会自动处理
- 性能优于应用层网关

缺点：

- 仍缺乏深度应用层感知
- 性能略有下降：需要额外的内存和CPU资源
- 易受**状态表溢出**攻击：攻击者发起大量半开连接

### 8.2.3 应用层防火墙WAF

当客户端试图访问某个资源时，并不直接与目标服务器通信，它首先向代理防火墙发送请求。代理防火墙接收到请求后，会根据协议解析请求的内容，并检查是否符合**安全策略**以决定是否**代表**客户端向目标服务器**发送请求**。如果请求被认
为安全且合法，代理防火墙与目标服务器建立连接，并转发客户端的请求。目标服务器返回响应数据，代理防火墙
再次检查返回的数据包，确保其内容安全并符合策略。

WAF过滤的方式包括基于特征（signature）、基于行为、基于语义分析等检测方法。

优点：

- **极高的安全性**
- **精细的控制能力**：过滤特定的关键字、软件、阻止访问恶意网站
- **支持用户级认证**：要求用户在访问资源之前进行登录

缺点：

- 性能开销大
- 部署复杂性高：需要为每一种应用协议配置特定的代理服务和规则集，管理和维护难度极高。如果应用程序使用的协议不是防火墙所支持的代理协议，那么该应用可能无法正常工作。
- 资源消耗高：由于需要维护大量并发的应用会话和进行深度包检测，需要更强大的硬件资源来运行



### 8.2.4 Netfilter

主要分为两个部分：

- Netfilter (内核空间)： 是 Linux 内核的一部分。它是一个框架，在网络协议栈的关键位置设置了“检查点”（Hooks），允许内核模块注册回调函数，从而拦截、检查和修改进出系统的每一个数据包。它是真正干活的“引擎”
- iptables (用户空间)： 是一个命令行工具。用户通过它来定义规则，并将这些规则传递给内核中的 Netfilter 去执行

Netfilter 的工作原理基于钩子函数 (Hooks)。课件定义了 5 个关键的钩子点

- **PREROUTING (路由前)：** 数据包刚进入网卡，还没有进行路由判断之前。常用于 DNAT（目标地址转换）。
- **INPUT (入站)：** 路由判断后，确定数据包是发给**本机**的，在进入本地进程之前触发。
- **FORWARD (转发)：** 路由判断后，确定数据包不是发给本机，而是需要经过本机**转发**给其他机器时触发。
- **OUTPUT (出站)：** **本机**进程产生的数据包，在即将发送出去之前触发。
- **POSTROUTING (路由后)：** 数据包即将离开网卡发送到网络之前。常用于 SNAT（源地址转换）

**数据包的流转路径** 

- **发给本机的包：** PREROUTING $\rightarrow$ INPUT $\rightarrow$ 本地进程
- **转发的包：** PREROUTING $\rightarrow$ FORWARD $\rightarrow$ POSTROUTING
- **本机发出的包：** OUTPUT $\rightarrow$ POSTROUTING

Netfilter 使用**“表-链-规则”**的层级结构来组织管理 ：

- **表 (Tables)：** 决定“做什么事情”（功能分类） 。
  - **filter 表：** 最常用。负责**过滤**（允许或拒绝）。包含 INPUT, FORWARD, OUTPUT 链。
  - **nat 表：** 负责**地址转换**（NAT）。用于端口转发或 IP 伪装。包含 PREROUTING, POSTROUTING 等链。
  - **mangle 表：** 负责**修改数据包**（如修改 TTL 或 QoS 标记）。
- **链 (Chains)：** 决定“在什么时间点做”（时机）。即上述的 5 个钩子点。
- **规则 (Rules)：** 具体的指令（如“丢弃 TCP 包”）

# 第九章 入侵检测系统

## 9.1 入侵检测系统分类

### 9.1.1 基于主机的入侵检测系统HIDS

优点：

- 基于主机的IDS可以检测到网络基础IDS无法察觉的攻击
- 基于主机的信息源是在数据加密之前生成的，或者在目的主机数据解密之后生成的
- 基于主机的IDS不受交换网络的影响
- 当基于主机的IDS运行在操作系统的审计迹线上时，它们可以帮助检测特洛伊木马或其他涉及软件完整性破坏的攻击

缺点：

- 必须为每个受监控的主机配置和管理信息
- IDS可能会在攻击中被攻击和禁用
- 基于主机的IDS会对被监控的系统造成性能损耗



### 9.1.2 基于网络的入侵检测系统NIDS

优点：

- NIDS使用**被动接口捕获**网络数据包以进行分析
- NIDS系统在网络保护方面具有良好的**可扩展性**，因为网络上实际的工作站、服务器或用户系统的数量并不关键关键是流量的多少
- 大多数基于网络的IDS是**操作系统独立**的
- 提供更好的防御DOS攻击的安全性

缺点：

- 如果网络流量被加密，则无法扫描协议或内容。
- 在现代交换网络上，入侵检测变得更加困难。
- 当前基于网络的监控方法无法有效处理高速网络。

## 9.2 入侵检测技术

### 9.2.1 基于误用的入侵检测（基于签名的入侵检测）

误用检测的工作原理是将传入的网络流量特征与一个已知攻击的特征数据库 (Signature Database) 进行比对

优点：

- **准确率高：** 对于已知的攻击，误报率非常低，因为它匹配的是确凿的攻击特征 。
- **效率高：** 类似于字符串查找，计算开销相对可控。
- **结果明确：** 一旦报警，管理员能清楚知道中了什么攻击。

缺点：

- 无法检测未知攻击： 如果攻击特征不在数据库里，系统就无法捕捉到。

- 需频繁更新： 必须像更新病毒库一样，时刻更新签名库才能防御新威胁。

- 容易被绕过： 攻击者稍微修改攻击代码（改变签名），就可能绕过检测（例如多态病毒）

### 9.2.2 基于异常的入侵检测

根据系统行为或资源使用状态的**正常程度**来进行判断，当检测行为与正常行为偏离较大时，发出告警信息

- 基于统计分析的异常检测： 构建正常行为的统计模型，通过数学统计的方法来识别偏离
- 基于机器学习的异常检测：利用人工智能算法自动学习“正常”和“异常”的分类边界

缺点：

- **误报率高**
- **建模困难：** 在复杂的网络环境中，定义什么是“正常”非常困难
- **需要大量数据训练**
- **难以应对伪装攻击**

## 9.3 Snort

**Snort** 是目前最流行、功能最完备的开源网络入侵检测系统（NIDS）。

Snort 的处理流程是一个流水线结构，数据包从进入网卡到最终生成报警，主要经过四个核心组件的处理：

- 数据包解码器
- 预处理器
- 检测引擎
- 日志和报警子系统 
